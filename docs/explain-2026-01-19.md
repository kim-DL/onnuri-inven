# EXPLAIN Evidence — 2026-01-19

## How to run

- Use Supabase SQL Editor. Copy each `EXPLAIN (ANALYZE, BUFFERS)` block and run as-is.
- Replace `:product_id` with a real UUID before running Pattern C.

---

## Pattern A — Active products list (name order)

Reproduction query (matches `/products` list fetch):

```sql
select id, name, manufacturer, zone_id, expiry_date, photo_url, unit
from public.products
where active = true
order by name;
```

EXPLAIN to run:

```sql
explain (analyze, buffers)
select id, name, manufacturer, zone_id, expiry_date, photo_url, unit
from public.products
where active = true
order by name;
```

EXPLAIN output: (awaiting output)

Interpretation:

- Expect sequential scan + sort without a supporting `(active, name)` index; high rows will spill to disk.
- Verify if `idx_products_active_name` (proposed) is used; it should produce an index scan with ordered output.
- Check buffer hits vs reads to gauge cache residency for the catalog table.

---

## Pattern B — Archived products list (with zone + inventory, ordered by archived_at)

Reproduction query (matches `list_archived_products` RPC body):

```sql
select
  p.id,
  p.name,
  coalesce(nullif(trim(p.manufacturer), ''), '') as manufacturer,
  coalesce(z.name, '') as zone_name,
  coalesce(i.stock, 0) as stock,
  p.archived_at,
  p.archived_reason
from public.products p
left join public.zones z on z.id = p.zone_id
left join public.inventory i on i.product_id = p.id
where p.active = false
order by p.archived_at desc nulls last, p.updated_at desc
limit 200;
```

EXPLAIN to run:

```sql
explain (analyze, buffers)
select
  p.id,
  p.name,
  coalesce(nullif(trim(p.manufacturer), ''), '') as manufacturer,
  coalesce(z.name, '') as zone_name,
  coalesce(i.stock, 0) as stock,
  p.archived_at,
  p.archived_reason
from public.products p
left join public.zones z on z.id = p.zone_id
left join public.inventory i on i.product_id = p.id
where p.active = false
order by p.archived_at desc nulls last, p.updated_at desc
limit 200;
```

EXPLAIN output: (awaiting output)

Interpretation:

- Current indexes lack coverage for `active=false` ordering; expect a filter then sort on `products` followed by nested loop left joins.
- Proposed partial index on `(archived_at desc nulls last, updated_at desc)` where `active=false` should turn the sort into an index scan.
- Verify join to `inventory` uses `inventory_pkey` (btree on product_id) and avoid hash join spill.

---

## Pattern C — Inventory logs by product (recent first)

Reproduction query (matches `get_inventory_logs_for_product` usage, limit 50):

```sql
select id, created_at, delta, before_stock, after_stock, note, created_by
from public.inventory_logs
where product_id = :product_id
order by created_at desc
limit 50;
```

EXPLAIN to run:

```sql
explain (analyze, buffers)
select id, created_at, delta, before_stock, after_stock, note, created_by
from public.inventory_logs
where product_id = :product_id
order by created_at desc
limit 50;
```

EXPLAIN output: (awaiting output)

Interpretation:

- Should use existing `idx_logs_product_created_at (product_id, created_at desc)` for an index scan with `Limit` on the index order.
- Check for `Rows Removed by Filter` to ensure the predicate is pushed into the index scan (it should be).
- Buffers should be mostly hits; any significant reads suggest growth requiring maintenance or further indexing.
