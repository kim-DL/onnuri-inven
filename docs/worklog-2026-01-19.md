# Worklog - 2026-01-19 (SSOT)

## Executive Summary

- Objective: validate Supabase contract (RLS/RPC), capture evidence, and publish a canonical SSOT patch without breaking contract constraints.
- Key decision: archived list stays direct select; products SELECT policy allows active users to read inactive rows (Option 1).
- Missing RPCs verified: `admin_set_user_display_name`, `get_inventory_logs_for_product` exist and match expected signatures.
- SSOT patch created: `db/patches/2026-01-19_backend_ssot.sql` (idempotent). Not applied yet (Human SQL Editor run required).
- EXPLAIN BEFORE/AFTER and zone index scan evidence pending Human run; smoke test NOT RUN.

## Scope & Guardrails

- Do Not Break Contract: no RPC signature/return changes, no column renames, no RLS scope changes, no direct stock updates.
- Changes limited to SSOT patch + worklog consolidation; app code unchanged.

## Contract Verification

- RLS: active users can read products/inventory/inventory_logs/zones/app_settings; admin-only writes on users_profile/zones; inventory insert constrained to stock=0.
- RPCs: `adjust_stock` guards inactive products and negative stock; admin RPCs check auth + active + admin; archive/restore/delete follow contract.
- Archived products access: direct select (`/products/archived`) supported by `products_select_active_user` policy (no active=true constraint).
- Repair Gate: NOT REQUIRED.

## Evidence - EXPLAIN (BEFORE/AFTER)

Human SQL Editor required for all EXPLAIN outputs and zone filter index scan proof.

- Pattern A (active list): `products` where `active=true` order by `name`.
- Pattern B (archived list): `products` where `active=false` order by `name`.
- Pattern C (inventory logs): `inventory_logs` by `product_id` order by `created_at desc` limit 50.
- Zone filter evidence: Index Scan showing `idx_products_active_zone_name_partial`.

Outputs are pending and tracked in the Raw Evidence appendix.

## Changes Applied / Planned (DB)

- SSOT patch created (not applied): `db/patches/2026-01-19_backend_ssot.sql`
  - Canonical RLS policies, RPC definitions, grants, archive constraint.
  - Canonical indexes: `idx_products_active_name_partial`, `idx_products_active_zone_name_partial`, `idx_products_inactive_name_partial`.
- No repair patch created.

## Smoke Test

- Status: NOT RUN.
- Owner/when: maintainer or QA after SSOT patch applied (staging preferred).

## Timeline

- 20:42 @ a4b7e62 - Initial snapshot, worklog created.
- 20:51 @ e04040e - Branch state recorded.
- 21:10 @ ad28d87 - Index patch draft committed.
- 22:09 @ 8f7ffab - Missing RPC definitions captured.
- 22:09 @ 8f7ffab - Snapshot: git status showed modified `docs/explain-2026-01-19.md`, `docs/todaywork.md`.
- 22:09 @ 8f7ffab - SSOT consolidation started; superseded docs scheduled for removal after patch/worklog commit.
- 22:09 @ 8f7ffab - Cleanup check: docs/db-usage-scan.md, docs/db-live-state.md, docs/explain-2026-01-19.md, docs/smoke-test-2026-01-19.md already absent; deletion skipped.

---

## Raw Evidence (verbatim)

### RPC definitions (SQL Editor output)

admin_set_user_display_name:
```sql
CREATE OR REPLACE FUNCTION public.admin_set_user_display_name(p_user_id uuid, p_display_name text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'pg_temp'
AS $function$
begin
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;

  if not public.is_active_user() then
    raise exception 'inactive user';
  end if;

  if not public.is_admin() then
    raise exception 'admin only';
  end if;

  update public.users_profile
  set display_name = nullif(trim(p_display_name), '')
  where user_id = p_user_id;
end;
$function$
```

get_inventory_logs_for_product:
```sql
CREATE OR REPLACE FUNCTION public.get_inventory_logs_for_product(p_product_id uuid, p_limit integer DEFAULT 50)
 RETURNS TABLE(id uuid, product_id uuid, zone_id uuid, delta integer, before_stock integer, after_stock integer, note text, created_at timestamp with time zone, created_by uuid, actor_name text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'pg_temp'
AS $function$
begin
  -- auth / active checks
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;

  if not public.is_active_user() then
    raise exception 'inactive user';
  end if;

  return query
  select
    l.id,
    l.product_id,
    l.zone_id,
    l.delta,
    l.before_stock,
    l.after_stock,
    l.note,
    l.created_at,
    l.created_by,
    nullif(trim(up.display_name), '') as actor_name
  from public.inventory_logs l
  left join public.users_profile up
    on up.user_id = l.created_by
  where l.product_id = p_product_id
  order by l.created_at desc
  limit greatest(1, least(p_limit, 200));
end;
$function$
```

### RLS policy output (SQL Editor)

```
[
  {
    "schemaname": "public",
    "tablename": "app_settings",
    "policyname": "app_settings_select_active",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "qual": "is_active_user()",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "inventory",
    "policyname": "inventory_insert_active_stock_zero",
    "roles": "{authenticated}",
    "cmd": "INSERT",
    "qual": null,
    "with_check": "(is_active_user() AND (stock = 0))"
  },
  {
    "schemaname": "public",
    "tablename": "inventory",
    "policyname": "inventory_select_active",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "qual": "is_active_user()",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "inventory_logs",
    "policyname": "inventory_logs_select_active",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "qual": "is_active_user()",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "products",
    "policyname": "products_insert_staff_admin",
    "roles": "{authenticated}",
    "cmd": "INSERT",
    "qual": null,
    "with_check": "is_active_user()"
  },
  {
    "schemaname": "public",
    "tablename": "products",
    "policyname": "products_select_active_user",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "qual": "is_active_user()",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "products",
    "policyname": "products_update_staff_admin",
    "roles": "{authenticated}",
    "cmd": "UPDATE",
    "qual": "is_active_user()",
    "with_check": "is_active_user()"
  },
  {
    "schemaname": "public",
    "tablename": "users_profile",
    "policyname": "users_profile_insert_admin",
    "roles": "{authenticated}",
    "cmd": "INSERT",
    "qual": null,
    "with_check": "is_admin()"
  },
  {
    "schemaname": "public",
    "tablename": "users_profile",
    "policyname": "users_profile_select_admin",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "qual": "is_admin()",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "users_profile",
    "policyname": "users_profile_select_self",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "qual": "(auth.uid() = user_id)",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "users_profile",
    "policyname": "users_profile_update_admin",
    "roles": "{authenticated}",
    "cmd": "UPDATE",
    "qual": "is_admin()",
    "with_check": "is_admin()"
  },
  {
    "schemaname": "public",
    "tablename": "zones",
    "policyname": "zones_admin_write",
    "roles": "{authenticated}",
    "cmd": "ALL",
    "qual": "is_admin()",
    "with_check": "is_admin()"
  },
  {
    "schemaname": "public",
    "tablename": "zones",
    "policyname": "zones_select_active",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "qual": "is_active_user()",
    "with_check": null
  }
]
```

### Index list output (SQL Editor)

```
[
  {
    "tablename": "inventory",
    "indexname": "inventory_pkey",
    "indexdef": "CREATE UNIQUE INDEX inventory_pkey ON public.inventory USING btree (product_id)"
  },
  {
    "tablename": "inventory_logs",
    "indexname": "idx_logs_product_created_at",
    "indexdef": "CREATE INDEX idx_logs_product_created_at ON public.inventory_logs USING btree (product_id, created_at DESC)"
  },
  {
    "tablename": "inventory_logs",
    "indexname": "idx_logs_zone_created_at",
    "indexdef": "CREATE INDEX idx_logs_zone_created_at ON public.inventory_logs USING btree (zone_id, created_at DESC)"
  },
  {
    "tablename": "inventory_logs",
    "indexname": "inventory_logs_pkey",
    "indexdef": "CREATE UNIQUE INDEX inventory_logs_pkey ON public.inventory_logs USING btree (id)"
  },
  {
    "tablename": "products",
    "indexname": "idx_products_zone_active",
    "indexdef": "CREATE INDEX idx_products_zone_active ON public.products USING btree (zone_id, active)"
  },
  {
    "tablename": "products",
    "indexname": "products_pkey",
    "indexdef": "CREATE UNIQUE INDEX products_pkey ON public.products USING btree (id)"
  }
]
```

### EXPLAIN outputs (BEFORE/AFTER)

Human run required (pending):

```sql
explain (analyze, buffers)
select id, name, manufacturer, zone_id, expiry_date, photo_url, unit
from public.products
where active = true
order by name;
```

```sql
explain (analyze, buffers)
select id, name, manufacturer, zone_id
from public.products
where active = false
order by name;
```

```sql
explain (analyze, buffers)
select id, created_at, delta, before_stock, after_stock, note, created_by
from public.inventory_logs
where product_id = :product_id
order by created_at desc
limit 50;
```

Zone filter index scan evidence (pending):

```sql
explain (analyze, buffers)
select id, name, manufacturer, zone_id, expiry_date, photo_url, unit
from public.products
where active = true
  and zone_id = :zone_id
order by name;
```

### Index creation SQL + execution record

Planned (not executed yet):

```sql
create index if not exists idx_products_active_name_partial
  on public.products (name)
  where active = true;

create index if not exists idx_products_active_zone_name_partial
  on public.products (zone_id, name)
  where active = true;

create index if not exists idx_products_inactive_name_partial
  on public.products (name)
  where active = false;
```

Execution log: NOT RUN (Human SQL Editor required).

### Smoke test record

Status: NOT RUN - owner: maintainer/QA; run after SSOT patch is applied (staging preferred).
