# Worklog - 2026-01-19 (SSOT)

## Executive Summary

- Objective: validate Supabase contract (RLS/RPC), capture evidence, and publish a canonical SSOT patch without breaking contract constraints.
- Key decision: archived list stays direct select; products SELECT policy allows active users to read inactive rows (Option 1).
- Missing RPCs verified: `admin_set_user_display_name`, `get_inventory_logs_for_product` exist and match expected signatures.
- SSOT patch created: `db/patches/2026-01-19_backend_ssot.sql` (idempotent). Not applied yet (Human SQL Editor run required).
- EXPLAIN BEFORE/AFTER and zone index scan evidence pending Human run; smoke test NOT RUN.

## Scope & Guardrails

- Do Not Break Contract: no RPC signature/return changes, no column renames, no RLS scope changes, no direct stock updates.
- Changes limited to SSOT patch + worklog consolidation; app code unchanged.

## Contract Verification

- RLS: active users can read products/inventory/inventory_logs/zones/app_settings; admin-only writes on users_profile/zones; inventory insert constrained to stock=0.
- RPCs: `adjust_stock` guards inactive products and negative stock; admin RPCs check auth + active + admin; archive/restore/delete follow contract.
- Archived products access: direct select (`/products/archived`) supported by `products_select_active_user` policy (no active=true constraint).
- Repair Gate: NOT REQUIRED.

## Evidence - EXPLAIN (BEFORE/AFTER)

Human SQL Editor required for all EXPLAIN outputs and zone filter index scan proof.

- Pattern A (active list): `products` where `active=true` order by `name`.
- Pattern B (archived list): `products` where `active=false` order by `name`.
- Pattern C (inventory logs): `inventory_logs` by `product_id` order by `created_at desc` limit 50.
- Zone filter evidence: Index Scan showing `idx_products_active_zone_name_partial`.

Outputs are pending and tracked in the Raw Evidence appendix.

## Changes Applied / Planned (DB)

- SSOT patch created (not applied): `db/patches/2026-01-19_backend_ssot.sql`
  - Canonical RLS policies, RPC definitions, grants, archive constraint.
  - Canonical indexes: `idx_products_active_name_partial`, `idx_products_active_zone_name_partial`, `idx_products_inactive_name_partial`.
- No repair patch created.

## Smoke Test

- Status: NOT RUN.
- Owner/when: maintainer or QA after SSOT patch applied (staging preferred).

## Timeline

- 20:42 @ a4b7e62 - Initial snapshot, worklog created.
- 20:51 @ e04040e - Branch state recorded.
- 21:10 @ ad28d87 - Index patch draft committed.
- 22:09 @ 8f7ffab - Missing RPC definitions captured.
- 22:09 @ 8f7ffab - Snapshot: git status showed modified `docs/explain-2026-01-19.md`, `docs/todaywork.md`.
- 22:09 @ 8f7ffab - SSOT consolidation started; superseded docs scheduled for removal after patch/worklog commit.
- 22:09 @ 8f7ffab - Cleanup check: docs/db-usage-scan.md, docs/db-live-state.md, docs/explain-2026-01-19.md, docs/smoke-test-2026-01-19.md already absent; deletion skipped.

---

## Raw Evidence (verbatim)

### RPC definitions (SQL Editor output)

admin_set_user_display_name:
```sql
CREATE OR REPLACE FUNCTION public.admin_set_user_display_name(p_user_id uuid, p_display_name text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'pg_temp'
AS $function$
begin
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;

  if not public.is_active_user() then
    raise exception 'inactive user';
  end if;

  if not public.is_admin() then
    raise exception 'admin only';
  end if;

  update public.users_profile
  set display_name = nullif(trim(p_display_name), '')
  where user_id = p_user_id;
end;
$function$
```

get_inventory_logs_for_product:
```sql
CREATE OR REPLACE FUNCTION public.get_inventory_logs_for_product(p_product_id uuid, p_limit integer DEFAULT 50)
 RETURNS TABLE(id uuid, product_id uuid, zone_id uuid, delta integer, before_stock integer, after_stock integer, note text, created_at timestamp with time zone, created_by uuid, actor_name text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'pg_temp'
AS $function$
begin
  -- auth / active checks
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;

  if not public.is_active_user() then
    raise exception 'inactive user';
  end if;

  return query
  select
    l.id,
    l.product_id,
    l.zone_id,
    l.delta,
    l.before_stock,
    l.after_stock,
    l.note,
    l.created_at,
    l.created_by,
    nullif(trim(up.display_name), '') as actor_name
  from public.inventory_logs l
  left join public.users_profile up
    on up.user_id = l.created_by
  where l.product_id = p_product_id
  order by l.created_at desc
  limit greatest(1, least(p_limit, 200));
end;
$function$
```

### RLS policy output (SQL Editor)

```
[
  {
    "schemaname": "public",
    "tablename": "app_settings",
    "policyname": "app_settings_select_active",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "qual": "is_active_user()",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "inventory",
    "policyname": "inventory_insert_active_stock_zero",
    "roles": "{authenticated}",
    "cmd": "INSERT",
    "qual": null,
    "with_check": "(is_active_user() AND (stock = 0))"
  },
  {
    "schemaname": "public",
    "tablename": "inventory",
    "policyname": "inventory_select_active",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "qual": "is_active_user()",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "inventory_logs",
    "policyname": "inventory_logs_select_active",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "qual": "is_active_user()",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "products",
    "policyname": "products_insert_staff_admin",
    "roles": "{authenticated}",
    "cmd": "INSERT",
    "qual": null,
    "with_check": "is_active_user()"
  },
  {
    "schemaname": "public",
    "tablename": "products",
    "policyname": "products_select_active_user",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "qual": "is_active_user()",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "products",
    "policyname": "products_update_staff_admin",
    "roles": "{authenticated}",
    "cmd": "UPDATE",
    "qual": "is_active_user()",
    "with_check": "is_active_user()"
  },
  {
    "schemaname": "public",
    "tablename": "users_profile",
    "policyname": "users_profile_insert_admin",
    "roles": "{authenticated}",
    "cmd": "INSERT",
    "qual": null,
    "with_check": "is_admin()"
  },
  {
    "schemaname": "public",
    "tablename": "users_profile",
    "policyname": "users_profile_select_admin",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "qual": "is_admin()",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "users_profile",
    "policyname": "users_profile_select_self",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "qual": "(auth.uid() = user_id)",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "users_profile",
    "policyname": "users_profile_update_admin",
    "roles": "{authenticated}",
    "cmd": "UPDATE",
    "qual": "is_admin()",
    "with_check": "is_admin()"
  },
  {
    "schemaname": "public",
    "tablename": "zones",
    "policyname": "zones_admin_write",
    "roles": "{authenticated}",
    "cmd": "ALL",
    "qual": "is_admin()",
    "with_check": "is_admin()"
  },
  {
    "schemaname": "public",
    "tablename": "zones",
    "policyname": "zones_select_active",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "qual": "is_active_user()",
    "with_check": null
  }
]
```

### Index list output (SQL Editor)

```
[
  {
    "tablename": "inventory",
    "indexname": "inventory_pkey",
    "indexdef": "CREATE UNIQUE INDEX inventory_pkey ON public.inventory USING btree (product_id)"
  },
  {
    "tablename": "inventory_logs",
    "indexname": "idx_logs_product_created_at",
    "indexdef": "CREATE INDEX idx_logs_product_created_at ON public.inventory_logs USING btree (product_id, created_at DESC)"
  },
  {
    "tablename": "inventory_logs",
    "indexname": "idx_logs_zone_created_at",
    "indexdef": "CREATE INDEX idx_logs_zone_created_at ON public.inventory_logs USING btree (zone_id, created_at DESC)"
  },
  {
    "tablename": "inventory_logs",
    "indexname": "inventory_logs_pkey",
    "indexdef": "CREATE UNIQUE INDEX inventory_logs_pkey ON public.inventory_logs USING btree (id)"
  },
  {
    "tablename": "products",
    "indexname": "idx_products_zone_active",
    "indexdef": "CREATE INDEX idx_products_zone_active ON public.products USING btree (zone_id, active)"
  },
  {
    "tablename": "products",
    "indexname": "products_pkey",
    "indexdef": "CREATE UNIQUE INDEX products_pkey ON public.products USING btree (id)"
  }
]
```

### EXPLAIN outputs (BEFORE/AFTER)

Human run required (pending):

```sql
explain (analyze, buffers)
select id, name, manufacturer, zone_id, expiry_date, photo_url, unit
from public.products
where active = true
order by name;
```

```sql
explain (analyze, buffers)
select id, name, manufacturer, zone_id
from public.products
where active = false
order by name;
```

```sql
explain (analyze, buffers)
select id, created_at, delta, before_stock, after_stock, note, created_by
from public.inventory_logs
where product_id = :product_id
order by created_at desc
limit 50;
```

Zone filter index scan evidence (pending):

```sql
explain (analyze, buffers)
select id, name, manufacturer, zone_id, expiry_date, photo_url, unit
from public.products
where active = true
  and zone_id = :zone_id
order by name;
```

### Index creation SQL + execution record

Planned (not executed yet):

```sql
create index if not exists idx_products_active_name_partial
  on public.products (name)
  where active = true;

create index if not exists idx_products_active_zone_name_partial
  on public.products (zone_id, name)
  where active = true;

create index if not exists idx_products_inactive_name_partial
  on public.products (name)
  where active = false;
```

## Smoke test: PASS (all 6 checks)

EXPLAIN: zone filter done (Seq Scan due to small table is acceptable), logs query uses idx_logs_product_created_at


## Raw Evidence (verbatim) — 2026-01-19 DB SSOT

### A) BEFORE Snapshot (패치 적용 전)

#### A1) Products indexes — BEFORE
(PASTE SQL + OUTPUT)
```sql
-- Query
select indexname, indexdef
from pg_indexes
where schemaname='public'
  and tablename='products'
  and indexname in (
    'idx_products_active_name_partial',
    'idx_products_active_zone_name_partial',
    'idx_products_inactive_name_partial'
  )
order by indexname;
text
코드 복사
-- Output
[
  {
    "indexname": "idx_products_active_name_partial",
    "indexdef": "CREATE INDEX idx_products_active_name_partial ON public.products USING btree (name) WHERE (active = true)"
  },
  {
    "indexname": "idx_products_active_zone_name_partial",
    "indexdef": "CREATE INDEX idx_products_active_zone_name_partial ON public.products USING btree (zone_id, name) WHERE (active = true)"
  },
  {
    "indexname": "idx_products_inactive_name_partial",
    "indexdef": "CREATE INDEX idx_products_inactive_name_partial ON public.products USING btree (name) WHERE (active = false)"
  }
]

A2) RPC definitions — BEFORE (admin_set_user_display_name, get_inventory_logs_for_product)

(PASTE SQL + OUTPUT)

-- Query
select p.proname as function_name, pg_get_functiondef(p.oid) as definition
from pg_proc p
join pg_namespace n on n.oid = p.pronamespace
where n.nspname='public'
  and p.proname in ('admin_set_user_display_name', 'get_inventory_logs_for_product')
order by p.proname;

-- Output
[
  {
    "function_name": "admin_set_user_display_name",
    "definition": "CREATE OR REPLACE FUNCTION public.admin_set_user_display_name(p_user_id uuid, p_display_name text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nbegin\r\n  if auth.uid() is null then\r\n    raise exception 'not authenticated';\r\n  end if;\r\n\r\n  if not public.is_active_user() then\r\n    raise exception 'inactive user';\r\n  end if;\r\n\r\n  if not public.is_admin() then\r\n    raise exception 'admin only';\r\n  end if;\r\n\r\n  update public.users_profile\r\n  set display_name = nullif(trim(p_display_name), '')\r\n  where user_id = p_user_id;\r\nend;\r\n$function$\n"
  },
  {
    "function_name": "get_inventory_logs_for_product",
    "definition": "CREATE OR REPLACE FUNCTION public.get_inventory_logs_for_product(p_product_id uuid, p_limit integer DEFAULT 50)\n RETURNS TABLE(id uuid, product_id uuid, zone_id uuid, delta integer, before_stock integer, after_stock integer, note text, created_at timestamp with time zone, created_by uuid, actor_name text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nbegin\r\n  if auth.uid() is null then\r\n    raise exception 'not authenticated';\r\n  end if;\r\n\r\n  if not public.is_active_user() then\r\n    raise exception 'inactive user';\r\n  end if;\r\n\r\n  return query\r\n  select\r\n    l.id,\r\n    l.product_id,\r\n    l.zone_id,\r\n    l.delta,\r\n    l.before_stock,\r\n    l.after_stock,\r\n    l.note,\r\n    l.created_at,\r\n    l.created_by,\r\n    nullif(trim(up.display_name), '') as actor_name\r\n  from public.inventory_logs l\r\n  left join public.users_profile up\r\n    on up.user_id = l.created_by\r\n  where l.product_id = p_product_id\r\n  order by l.created_at desc\r\n  limit greatest(1, least(p_limit, 200));\r\nend;\r\n$function$\n"
  }
]

A3) Products RLS policies — BEFORE

(PASTE SQL + OUTPUT)

-- Query
select schemaname, tablename, policyname, permissive, roles, cmd, qual, with_check
from pg_policies
where schemaname='public'
  and tablename='products'
order by policyname;

-- Output
[
  {
    "schemaname": "public",
    "tablename": "products",
    "policyname": "products_insert_staff_admin",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "INSERT",
    "qual": null,
    "with_check": "is_active_user()"
  },
  {
    "schemaname": "public",
    "tablename": "products",
    "policyname": "products_select_active_user",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "qual": "is_active_user()",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "products",
    "policyname": "products_update_staff_admin",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "UPDATE",
    "qual": "is_active_user()",
    "with_check": "is_active_user()"
  }
]

B) SSOT Patch Application (패치 실행 기록)
B1) SSOT patch executed: db/patches/2026-01-19_backend_ssot.sql

(PASTE execution log: success / notices / errors)

succes

C) AFTER Snapshot (패치 적용 후)
C1) Products indexes — AFTER

(Repeat A1 and paste output)

[
  {
    "indexname": "idx_products_active_name_partial",
    "indexdef": "CREATE INDEX idx_products_active_name_partial ON public.products USING btree (name) WHERE (active = true)"
  },
  {
    "indexname": "idx_products_active_zone_name_partial",
    "indexdef": "CREATE INDEX idx_products_active_zone_name_partial ON public.products USING btree (zone_id, name) WHERE (active = true)"
  },
  {
    "indexname": "idx_products_inactive_name_partial",
    "indexdef": "CREATE INDEX idx_products_inactive_name_partial ON public.products USING btree (name) WHERE (active = false)"
  }
]

C2) RPC definitions — AFTER

(Repeat A2 and paste output)

[
  {
    "function_name": "admin_set_user_display_name",
    "definition": "CREATE OR REPLACE FUNCTION public.admin_set_user_display_name(p_user_id uuid, p_display_name text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nbegin\r\n  if auth.uid() is null then\r\n    raise exception 'not authenticated';\r\n  end if;\r\n\r\n  if not public.is_active_user() then\r\n    raise exception 'inactive user';\r\n  end if;\r\n\r\n  if not public.is_admin() then\r\n    raise exception 'admin only';\r\n  end if;\r\n\r\n  update public.users_profile\r\n  set display_name = nullif(trim(p_display_name), '')\r\n  where user_id = p_user_id;\r\nend;\r\n$function$\n"
  },
  {
    "function_name": "get_inventory_logs_for_product",
    "definition": "CREATE OR REPLACE FUNCTION public.get_inventory_logs_for_product(p_product_id uuid, p_limit integer DEFAULT 50)\n RETURNS TABLE(id uuid, product_id uuid, zone_id uuid, delta integer, before_stock integer, after_stock integer, note text, created_at timestamp with time zone, created_by uuid, actor_name text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nbegin\r\n  if auth.uid() is null then\r\n    raise exception 'not authenticated';\r\n  end if;\r\n\r\n  if not public.is_active_user() then\r\n    raise exception 'inactive user';\r\n  end if;\r\n\r\n  return query\r\n  select\r\n    l.id,\r\n    l.product_id,\r\n    l.zone_id,\r\n    l.delta,\r\n    l.before_stock,\r\n    l.after_stock,\r\n    l.note,\r\n    l.created_at,\r\n    l.created_by,\r\n    nullif(trim(up.display_name), '') as actor_name\r\n  from public.inventory_logs l\r\n  left join public.users_profile up\r\n    on up.user_id = l.created_by\r\n  where l.product_id = p_product_id\r\n  order by l.created_at desc\r\n  limit greatest(1, least(p_limit, 200));\r\nend;\r\n$function$\n"
  }
]

C3) Products RLS policies — AFTER

(Repeat A3 and paste output)

[
  {
    "schemaname": "public",
    "tablename": "products",
    "policyname": "products_insert_staff_admin",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "INSERT",
    "qual": null,
    "with_check": "is_active_user()"
  },
  {
    "schemaname": "public",
    "tablename": "products",
    "policyname": "products_select_active_user",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "SELECT",
    "qual": "is_active_user()",
    "with_check": null
  },
  {
    "schemaname": "public",
    "tablename": "products",
    "policyname": "products_update_staff_admin",
    "permissive": "PERMISSIVE",
    "roles": "{authenticated}",
    "cmd": "UPDATE",
    "qual": "is_active_user()",
    "with_check": "is_active_user()"
  }
]

D) EXPLAIN Evidence (각 쿼리 1개씩, 단일 statement만)
D1) EXPLAIN — Active products list
explain (analyze, buffers)
select id, name, manufacturer, zone_id, expiry_date, photo_url, unit
from public.products
where active = true
order by name;

[
  {
    "QUERY PLAN": "Sort  (cost=1.18..1.20 rows=7 width=161) (actual time=8.796..8.797 rows=8 loops=1)"
  },
  {
    "QUERY PLAN": "  Sort Key: name"
  },
  {
    "QUERY PLAN": "  Sort Method: quicksort  Memory: 26kB"
  },
  {
    "QUERY PLAN": "  Buffers: shared hit=4"
  },
  {
    "QUERY PLAN": "  ->  Seq Scan on products  (cost=0.00..1.08 rows=7 width=161) (actual time=1.198..1.207 rows=8 loops=1)"
  },
  {
    "QUERY PLAN": "        Filter: active"
  },
  {
    "QUERY PLAN": "        Buffers: shared hit=1"
  },
  {
    "QUERY PLAN": "Planning:"
  },
  {
    "QUERY PLAN": "  Buffers: shared hit=164"
  },
  {
    "QUERY PLAN": "Planning Time: 6.271 ms"
  },
  {
    "QUERY PLAN": "Execution Time: 8.900 ms"
  }
]

D2) EXPLAIN — Archived products list (direct select)
explain (analyze, buffers)
select id, name, manufacturer, zone_id
from public.products
where active = false
order by name;

[
  {
    "QUERY PLAN": "Sort  (cost=1.09..1.09 rows=1 width=65) (actual time=0.048..0.048 rows=0 loops=1)"
  },
  {
    "QUERY PLAN": "  Sort Key: name"
  },
  {
    "QUERY PLAN": "  Sort Method: quicksort  Memory: 25kB"
  },
  {
    "QUERY PLAN": "  Buffers: shared hit=4"
  },
  {
    "QUERY PLAN": "  ->  Seq Scan on products  (cost=0.00..1.08 rows=1 width=65) (actual time=0.024..0.024 rows=0 loops=1)"
  },
  {
    "QUERY PLAN": "        Filter: (NOT active)"
  },
  {
    "QUERY PLAN": "        Rows Removed by Filter: 8"
  },
  {
    "QUERY PLAN": "        Buffers: shared hit=1"
  },
  {
    "QUERY PLAN": "Planning:"
  },
  {
    "QUERY PLAN": "  Buffers: shared hit=155"
  },
  {
    "QUERY PLAN": "Planning Time: 0.519 ms"
  },
  {
    "QUERY PLAN": "Execution Time: 0.117 ms"
  }
]

D3) EXPLAIN — Inventory logs (replace product_id)
explain (analyze, buffers)
select id, created_at, delta, before_stock, after_stock, note, created_by
from public.inventory_logs
where product_id = 'd7a2bd92-2a64-43ce-8918-8f7b69dfec56'
order by created_at desc
limit 50;

[
  {
    "QUERY PLAN": "Limit  (cost=4.47..4.48 rows=3 width=84) (actual time=2.390..2.395 rows=21 loops=1)"
  },
  {
    "QUERY PLAN": "  Buffers: shared hit=5"
  },
  {
    "QUERY PLAN": "  ->  Sort  (cost=4.47..4.48 rows=3 width=84) (actual time=2.389..2.391 rows=21 loops=1)"
  },
  {
    "QUERY PLAN": "        Sort Key: created_at DESC"
  },
  {
    "QUERY PLAN": "        Sort Method: quicksort  Memory: 27kB"
  },
  {
    "QUERY PLAN": "        Buffers: shared hit=5"
  },
  {
    "QUERY PLAN": "        ->  Bitmap Heap Scan on inventory_logs  (cost=1.27..4.45 rows=3 width=84) (actual time=2.319..2.325 rows=21 loops=1)"
  },
  {
    "QUERY PLAN": "              Recheck Cond: (product_id = 'd7a2bd92-2a64-43ce-8918-8f7b69dfec56'::uuid)"
  },
  {
    "QUERY PLAN": "              Heap Blocks: exact=1"
  },
  {
    "QUERY PLAN": "              Buffers: shared hit=2"
  },
  {
    "QUERY PLAN": "              ->  Bitmap Index Scan on idx_logs_product_created_at  (cost=0.00..1.27 rows=3 width=0) (actual time=1.197..1.197 rows=21 loops=1)"
  },
  {
    "QUERY PLAN": "                    Index Cond: (product_id = 'd7a2bd92-2a64-43ce-8918-8f7b69dfec56'::uuid)"
  },
  {
    "QUERY PLAN": "                    Buffers: shared hit=1"
  },
  {
    "QUERY PLAN": "Planning:"
  },
  {
    "QUERY PLAN": "  Buffers: shared hit=121"
  },
  {
    "QUERY PLAN": "Planning Time: 3.541 ms"
  },
  {
    "QUERY PLAN": "Execution Time: 2.476 ms"
  }
]

explain (analyze, buffers)
select id, name, manufacturer, zone_id
from public.products
where active = true
  and zone_id = 'c9882658-6729-4618-97c0-221d5ffd8426'
order by name;

[
  {
    "QUERY PLAN": "Sort  (cost=1.12..1.13 rows=3 width=65) (actual time=2.626..2.626 rows=3 loops=1)"
  },
  {
    "QUERY PLAN": "  Sort Key: name"
  },
  {
    "QUERY PLAN": "  Sort Method: quicksort  Memory: 25kB"
  },
  {
    "QUERY PLAN": "  Buffers: shared hit=4"
  },
  {
    "QUERY PLAN": "  ->  Seq Scan on products  (cost=0.00..1.10 rows=3 width=65) (actual time=0.021..0.026 rows=3 loops=1)"
  },
  {
    "QUERY PLAN": "        Filter: (active AND (zone_id = 'c9882658-6729-4618-97c0-221d5ffd8426'::uuid))"
  },
  {
    "QUERY PLAN": "        Rows Removed by Filter: 5"
  },
  {
    "QUERY PLAN": "        Buffers: shared hit=1"
  },
  {
    "QUERY PLAN": "Planning:"
  },
  {
    "QUERY PLAN": "  Buffers: shared hit=162"
  },
  {
    "QUERY PLAN": "Planning Time: 0.578 ms"
  },
  {
    "QUERY PLAN": "Execution Time: 2.704 ms"
  }
]

### E) Smoke Test (PASS/FAIL)

- Login gate: PASS — 정상 로그인/리다이렉트 확인
- Products list: PASS — 목록 로드/검색/zone 필터/상세 이동 정상
- Product detail: PASS — 상세 렌더/로그 섹션 정상
- adjust_stock IN/OUT + logs: PASS — 재고 반영 + 로그 생성 정상
- Archived list restore/delete: PASS — archived 조회/복구 정상 (권한 동작 포함)
- Settings (admin): PASS — 설정 저장/반영 정상 (권한 제한 정상)